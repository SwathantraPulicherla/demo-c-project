/* test_temp_sensor.c – Auto-generated Expert Unity Tests */

#include "unity.h"
#include "temp_sensor.h"   // To declare functions under test
#include <stdbool.h>       // For bool type
#include <string.h>        // For memset
#include <stdint.h>        // For uint32_t

// External function declaration for the function to be stubbed.
// This typically comes from "temp_converter.h".
extern float raw_to_celsius(int raw_value);

// --- STUB DEFINITIONS ---

// Control structure for the raw_to_celsius stub
typedef struct {
    float return_value;
    bool was_called;
    uint32_t call_count;
    int last_raw_value; // Captures the last raw_value parameter passed to the stub
} stub_raw_to_celsius_t;

// Static instance of the stub control structure, initialized to zeros.
static stub_raw_to_celsius_t stub_raw_to_celsius = {0};

// Stub implementation for raw_to_celsius
float raw_to_celsius(int raw_value) {
    stub_raw_to_celsius.was_called = true;
    stub_raw_to_celsius.call_count++;
    stub_raw_to_celsius.last_raw_value = raw_value;
    return stub_raw_to_celsius.return_value;
}

// --- UNITY SETUP AND TEARDOWN ---

void setUp(void) {
    // Reset all stub control structures to their default (zero) state
    memset(&stub_raw_to_celsius, 0, sizeof(stub_raw_to_celsius));
    // Set default return values for stubs if needed (already 0.0f from memset for floats)
    stub_raw_to_celsius.return_value = 0.0f; // Explicitly set default for clarity
}

void tearDown(void) {
    // Reset all stub control structures to ensure test isolation
    memset(&stub_raw_to_celsius, 0, sizeof(stub_raw_to_celsius));
    // Explicitly set default return values again for robustness
    stub_raw_to_celsius.return_value = 0.0f;
}

// --- TEST FUNCTIONS ---

// Test for read_temperature_raw()
// This function calls rand() which is not listed as an external function to stub.
// Therefore, it cannot be made deterministic. We test its output range.
void test_read_temperature_raw_returns_within_expected_range(void) {
    int raw_value;
    // Call multiple times to increase confidence that the value stays within 00.0f
    for (int i = 0; i < 100; i++) {
        raw_value = read_temperature_raw();
        // Expected: Raw value generated by rand() % 1024 should always be between 0 and 1023 inclusive.
        TEST_ASSERT_TRUE(raw_value >= 0 && raw_value <= 1023);
    }
}

// Tests for validate_temperature_range(float temp_c)
void test_validate_temperature_range_nominal_valid(void) {
    float temp = 25.0f; // A typical, valid operating temperature
    bool result = validate_temperature_range(temp);
    // Expected: 25.0f is within [0.0f, 125.0f], so should return true.
    TEST_ASSERT_TRUE(result);
}

void test_validate_temperature_range_min_edge_valid(void) {
    float temp = 0.0f; // Minimum allowed temperature
    bool result = validate_temperature_range(temp);
    // Expected: 0.0f is exactly the lower bound, so should return true.
    TEST_ASSERT_TRUE(result);
}

void test_validate_temperature_range_max_edge_valid(void) {
    float temp = 125.0f; // Maximum allowed temperature
    bool result = validate_temperature_range(temp);
    // Expected: 125.0f is exactly the upper bound, so should return true.
    TEST_ASSERT_TRUE(result);
}

void test_validate_temperature_range_below_min_invalid(void) {
    float temp = 0.0f; // Just below the minimum allowed temperature
    bool result = validate_temperature_range(temp);
    // Expected: 0.0f is less than 0.0f, so should return false.
    TEST_ASSERT_FALSE(result);
}

void test_validate_temperature_range_above_max_invalid(void) {
    float temp = 125.1f; // Just above the maximum allowed temperature
    bool result = validate_temperature_range(temp);
    // Expected: 125.1f is greater than 125.0f, so should return false.
    TEST_ASSERT_FALSE(result);
}

// Tests for check_temperature_status(float temp_c)
void test_check_temperature_status_critical_above_max_threshold(void) {
    float temp = 120.1f; // Just above the 120.0f threshold for CRITICAL
    const char* status = check_temperature_status(temp);
    // Expected: 120.1f > 120.0f, so status should be "CRITICAL".
    TEST_ASSERT_EQUAL_STRING("CRITICAL", status);
}

void test_check_temperature_status_hot_at_critical_boundary(void) {
    float temp = 120.0f; // At the 120.0f threshold, but not strictly greater
    const char* status = check_temperature_status(temp);
    // Expected: 120.0f is not > 120.0f, but it is > 85.0f, so status should be "HOT".
    TEST_ASSERT_EQUAL_STRING("HOT", status);
}

void test_check_temperature_status_hot_above_hot_threshold(void) {
    float temp = 85.1f; // Just above the 85.0f threshold for HOT
    const char* status = check_temperature_status(temp);
    // Expected: 85.1f is not > 120.0f, but it is > 85.0f, so status should be "HOT".
    TEST_ASSERT_EQUAL_STRING("HOT", status);
}

void test_check_temperature_status_normal_at_hot_boundary(void) {
    float temp = 85.0f; // At the 85.0f threshold, but not strictly greater
    const char* status = check_temperature_status(temp);
    // Expected: 85.0f is not > 120.0f and not > 85.0f, and not < 0.0f, so status should be "NORMAL".
    TEST_ASSERT_EQUAL_STRING("NORMAL", status);
}

void test_check_temperature_status_normal_mid_range(void) {
    float temp = 25.0f; // A typical normal temperature
    const char* status = check_temperature_status(temp);
    // Expected: 25.0f is within the normal range, so status should be "NORMAL".
    TEST_ASSERT_EQUAL_STRING("NORMAL", status);
}

void test_check_temperature_status_normal_at_cold_boundary(void) {
    float temp = 0.0f; // At the 0.0f threshold, but not strictly less
    const char* status = check_temperature_status(temp);
    // Expected: 0.0f is not > 120.0f, not > 85.0f, and not < 0.0f, so status should be "NORMAL".
    TEST_ASSERT_EQUAL_STRING("NORMAL", status);
}

void test_check_temperature_status_cold_below_cold_threshold(void) {
    float temp = 0.0f; // Just below the 0.0f threshold for COLD
    const char* status = check_temperature_status(temp);
    // Expected: 0.0f is < 0.0f, so status should be "COLD".
    TEST_ASSERT_EQUAL_STRING("COLD", status);
}

void test_check_temperature_status_cold_min_valid_temp(void) {
    float temp = 0.0f; // Minimum valid temperature, which falls into the COLD category
    const char* status = check_temperature_status(temp);
    // Expected: 0.0f is < 0.0f, so status should be "COLD".
    TEST_ASSERT_EQUAL_STRING("COLD", status);
}

// Tests for get_temperature_celsius()
void test_get_temperature_celsius_nominal_value(void) {
    // Configure the stub to return a nominal temperature value
    stub_raw_to_celsius.return_value = 25.5f;
    float result = get_temperature_celsius();

    // Expected: The raw_to_celsius stub should have been called exactly once.
    TEST_ASSERT_TRUE(stub_raw_to_celsius.was_called);
    TEST_ASSERT_EQUAL_UINT32(1, stub_raw_to_celsius.call_count);
    // Expected: The raw_value passed to the stub should be within the 00.0f range (from read_temperature_raw()).
    TEST_ASSERT_TRUE(stub_raw_to_celsius.last_raw_value >= 0 && stub_raw_to_celsius.last_raw_value <= 1023);
    // Expected: The function should return the value configured in the stub.
    TEST_ASSERT_FLOAT_WITHIN(0.1f, 25.5f, result);
}

void test_get_temperature_celsius_cold_value(void) {
    // Configure the stub to return a cold temperature value
    stub_raw_to_celsius.return_value = 0.0f;
    float result = get_temperature_celsius();

    // Expected: The raw_to_celsius stub should have been called exactly once.
    TEST_ASSERT_TRUE(stub_raw_to_celsius.was_called);
    TEST_ASSERT_EQUAL_UINT32(1, stub_raw_to_celsius.call_count);
    // Expected: The raw_value passed to the stub should be within the 00.0f range.
    TEST_ASSERT_TRUE(stub_raw_to_celsius.last_raw_value >= 0 && stub_raw_to_celsius.last_raw_value <= 1023);
    // Expected: The function should return the value configured in the stub.
    TEST_ASSERT_FLOAT_WITHIN(0.1f, 0.0f, result);
}

void test_get_temperature_celsius_hot_value(void) {
    // Configure the stub to return a hot temperature value
    stub_raw_to_celsius.return_value = 90.0f;
    float result = get_temperature_celsius();

    // Expected: The raw_to_celsius stub should have been called exactly once.
    TEST_ASSERT_TRUE(stub_raw_to_celsius.was_called);
    TEST_ASSERT_EQUAL_UINT32(1, stub_raw_to_celsius.call_count);
    // Expected: The raw_value passed to the stub should be within the 00.0f range.
    TEST_ASSERT_TRUE(stub_raw_to_celsius.last_raw_value >= 0 && stub_raw_to_celsius.last_raw_value <= 1023);
    // Expected: The function should return the value configured in the stub.
    TEST_ASSERT_FLOAT_WITHIN(0.1f, 90.0f, result);
}

// --- MAIN UNITY RUNNER ---



int main(void) {
    UNITY_BEGIN();

    RUN_TEST(test_read_temperature_raw_returns_within_expected_range);
    RUN_TEST(test_validate_temperature_range_nominal_valid);
    RUN_TEST(test_validate_temperature_range_min_edge_valid);
    RUN_TEST(test_validate_temperature_range_max_edge_valid);
    RUN_TEST(test_validate_temperature_range_below_min_invalid);
    RUN_TEST(test_validate_temperature_range_above_max_invalid);
    RUN_TEST(test_check_temperature_status_critical_above_max_threshold);
    RUN_TEST(test_check_temperature_status_hot_at_critical_boundary);
    RUN_TEST(test_check_temperature_status_hot_above_hot_threshold);
    RUN_TEST(test_check_temperature_status_normal_at_hot_boundary);
    RUN_TEST(test_check_temperature_status_normal_mid_range);
    RUN_TEST(test_check_temperature_status_normal_at_cold_boundary);
    RUN_TEST(test_check_temperature_status_cold_below_cold_threshold);
    RUN_TEST(test_check_temperature_status_cold_min_valid_temp);
    RUN_TEST(test_get_temperature_celsius_nominal_value);
    RUN_TEST(test_get_temperature_celsius_cold_value);
    RUN_TEST(test_get_temperature_celsius_hot_value);

    return UNITY_END();
}